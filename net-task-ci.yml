version: 1
name: build_tasks
externals:
  - ./net-task.yml
tasks:
  ci:sign:
    os: macos
    shell: |
      set -e
      set -x

      echo $MACOS_CERTIFICATE | base64 --decode > tmp_cert.p12
      security create-keychain -p "$MACOS_CI_KEYCHAIN_PWD" $KEYCHAIN_NAME
      security default-keychain -s $KEYCHAIN_NAME
      security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" $KEYCHAIN_NAME

      # Which intermediate cert do you really need? open the details in your cert in Keychain Access
      # and under issuer check common name AND org unit. Then use curl to download appropriate
      # certs from https://www.apple.com/certificateauthority/
      # here our common ID was Developer ID and our org unit G2
      # so we found the Developer ID - G2 link on that page
      echo "downloading intermediate cert from apple to complete trust chain"
      curl https://www.apple.com/certificateauthority/AppleWWDRCAG3.cer -o /tmp/apple_cert.cer
      sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /tmp/apple_cert.cer

      curl https://www.apple.com/certificateauthority/DeveloperIDG2CA.cer -o /tmp/apple_cert_g2.cer
      sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /tmp/apple_cert_g2.cer

      echo "importing our own cert"
      security import tmp_cert.p12 -k $KEYCHAIN_NAME -P "$MACOS_CERTIFICATE_PWD" -T /usr/bin/codesign
      security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$MACOS_CI_KEYCHAIN_PWD" $KEYCHAIN_NAME

      security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" $KEYCHAIN_NAME

      /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" --options runtime target/release/net-task -v

      # Double check
      /usr/bin/codesign -vvv --deep target/release/net-task

  ci:notorize:
    os: macos
    description: after ci:sign, this notorizes the app and places the result in target/net-task
    shell: |
      set -x

      RELEASE_VERSION=$($NET_TASK run build:get-current-version)
      BUILD_INFO="${RELEASE_VERSION}_$(uname -o | cut -d'/' -f2)_$(uname -m)"

      ARCHIVE_NAME="net-task_${BUILD_INFO}.zip"
      ditto -c -k target/release/net-task $ARCHIVE_NAME
      echo $ARCHIVE_NAME > target/archive_name

      echo "notorizing app (may take a minute...)"

      xcrun notarytool store-credentials "notarytool-profile" --apple-id "$MACOS_NOTARIZATION_APPLE_ID" --team-id "$MACOS_NOTARIZATION_TEAM_ID" --password "$MACOS_NOTARIZATION_PWD"

      xcrun notarytool submit "net-task_${BUILD_INFO}.zip" --keychain-profile "notarytool-profile" --wait
      mkdir target/net-task
      mv $ARCHIVE_NAME target/net-task

  ci:gh:auth:
    description: authorize
    os: unix
    shell: |
      echo "$GH_BOT_KEY" > /tmp/gh-token
      if [ ! -f /tmp/gh-token ]; then
        echo "File /tmp/gh-token does not exist. Exiting."
        exit 1
      fi
      gh auth login --with-token < /tmp/gh-token
      rm /tmp/gh-token

  ci:gh:create-release-draft:
    description: Create a Draft release for binary uploads
    os: unix
    shell: |
      set -e

      # $NET_TASK -t ./net-task-ci.yml run ci:gh:auth
      VERSION=$($NET_TASK run build:get-current-version)
      TITLE="Release $VERSION"
      gh release create --repo rwilcox/net-task $VERSION --title="$TITLE" --generate-notes -d

  ci:create-arch-tagged-release:
    os: unix
    description: create a .tar.gz arch specific release
    shell: |
      set -e
      set -x
      # dependencies
      $NET_TASK run build:release
      RELEASE_VERSION=$($NET_TASK run build:get-current-version)

      mkdir -p target/net-task
      RELEASE_PATH="release"
      mv target/$RELEASE_PATH/net-task target/net-task/net-task

      # gives us ie Darwin_arm64 or whatever
      BUILD_INFO="${RELEASE_VERSION}_$(uname -o | cut -d'/' -f2)_$(uname -m)"
      mkdir -p target/net-task
      ARCHIVE_NAME="target/net-task/net-task_${BUILD_INFO}.tar.gz"
      tar -czf $ARCHIVE_NAME -C target/net-task/ net-task
      rm target/net-task/net-task # only .tar.gz etc files here
      echo $ARCHIVE_NAME > target/archive_name
      echo "done creating architecture specific .tar.gz files"

  ci:gh:test:release_tag:
    os: unix
    description: test if the release stuff WOULD be triggered
    shell: |
      set -e
      RELEASE_TAG=$(gh release list --json name --json isDraft --json tagName --jq '.[] | select(.isDraft == true) | .tagName')

      if [ -z $RELEASE_TAG ]; then
        echo "no release tag, assuming not releasable in current state"
        exit 0
      fi
      echo "release tag found"

  ci:gh:upload-binary:
    os: unix
    description: upload the binary to the latest draft Release
    shell: |
      set -e

      # users need to manually run the following dependencies at some time:
      #   * ci:gh:auth
      #   * ci:create-arch-tagged-release

      # let CI take care of creating the release
      # that is the control on if we want uploads to happen: if there is a
      # draft Release
      RELEASE_TAG=$(gh release list --json name --json isDraft --json tagName --jq '.[] | select(.isDraft == true) | .tagName')

      if [ -z $RELEASE_TAG ]; then
        echo "no release tag, assuming not releasable in current state"
        exit 0
      fi

      gh release upload $RELEASE_TAG built-binaries/net-task/net-task_*

      # alternatively we could have used npx publish-release
      # example: https://github.com/rwilcox/codenarc-cli/blob/master/build-scripts/release.sh
      # but the GH CLI feels like it will be more maintained
      # now upload the currently built file
      # using gh subcommands
      # WD-rpw 10/17/2024
